    /*
    while (sBody >> word)
    {
        if (isType(word)) {
            sBody >> word;
            if (!word.empty()) {
                auto functionStart = word.find('(');
                if (functionStart != std::string::npos) {
                    std::string methodName = word.substr(0, functionStart);
                    while (sBody >> word)
                    {
                        if (word.find(')') != std::string::npos) {
                            
                            break;
                        }
                    }
                } else {
                    isKeyword(word) ? throw ErrorMessage("Variable can not have name of keyword!\n")
                                : ++propertyCount;
                }
            }
            else {
                break;
            }
        }
    }
    */
    //std::cout << "Member functions: " << functionCount << std::endl;   


/*
{
    std::stringstream   streamFunctionName(body);
    std::string         word;
    std::string         funcReturnType;

    std::string     functionName;
    while (streamFunctionName >> word)
    {
        if (isType(word)) {
            funcReturnType = word;
            streamFunctionName >> word;
            if (word.empty()) {
                break;
            }
            auto isCleanName = word.find("(");
            if (isCleanName != std::string::npos) {
                functionName = word.substr(0, isCleanName);
            } else {
                functionName = word;
            }
            break;
        }
    }
    streamFunctionName.clear();
    
    std::string funcBody;
    size_t  endIndex = 0;
    while (!body[i].empty())
    {
        auto fEnd = body[i].find("}");
        if (fEnd != std::string::npos) {
            endIndex = i;
            break;
        }
        ++i;
    }

    while (i < endIndex + 1)
    {
        funcBody += body[i++];
    }

    auto fStart = funcBody.find(funcReturnType);
    auto fEnd = funcBody.find("}");
    if (fStart == std::string::npos || fEnd == std::string::npos) {
        throw ErrorMessage("Error occured during parsing!\n");
    }
    funcBody = funcBody.find(fStart, fEnd - fStart + 1);

    auto argStart = funcBody.find("(");
    auto argEnd = funcBody.find(")");
    if (argStart == std::string::npos || argEnd == std::string::npos) {
        throw ErrorMessage("Function's parametrs must be pn the same line as its name\n");
    }
    size_t  argCount;
    std::string argumentScope = funcBody.substr(argStart + 1, argEnd - argStart - 1);

    std::stringstream    streamScope(argumentScope);
    while (streamScope >> word)
    {
        if (isType(word)) {
            streamScope >> word;
            if (word.empty()) {
                break;
            }
            if (isKeyword(word)) {
                throw ErrorMessage("Argument name can not be a keyword!\n");
            }
            ++argCount;
        }
    }
    streamScope.clear();
    funcBody = funcBody.substr(argEnd + 1, funcBody.size() - argEnd + 1);
    size_t  variableCount = functionVariableCount(funcBody);

    outputStream_ << functionName << " has " << argCount << " arguments and " << variableCount << " variables in the body\n";

    return endIndex;
}
*/


 void  Analyzer::functionAnalysis(std::string& body)
{
    std::stringstream   streamFunctionName(body);
    std::string         word;
    std::string         funcReturnType;

    std::string     functionName;
    while (streamFunctionName >> word)
    {
        if (isType(word)) {
            funcReturnType = word;
            streamFunctionName >> word;
            if (word.empty()) {
                break;
            }
            auto isCleanName = word.find("(");
            if (isCleanName != std::string::npos) {
                functionName = word.substr(0, isCleanName);
            } else {
                functionName = word;
            }
            break;
        }
    }
    streamFunctionName.clear();

    auto fStart = body.find(funcReturnType);
    if (fStart == std::string::npos) {
        throw ErrorMessage("Error occured during parsing!\n");
    }
    auto fEnd = body.find("}");
    if (fEnd == std::string::npos) { 
        throw ErrorMessage("Error occured during parsing!\n");
    }

    std::string funcBody = body.substr(fStart, fEnd  - fStart + 1);
    std::string temp = body.substr(0, fStart);
    temp += body.substr(fEnd + 1, input_.size() - fEnd - 1);
    body = temp;

    auto argStart = funcBody.find("(");
    auto argEnd = funcBody.find(")");
    if (argStart == std::string::npos || argEnd == std::string::npos) {
        throw ErrorMessage("Function's parameters must be on the same line as its name\n");
    }
    size_t  argCount = 0;
    std::string argumentScope = funcBody.substr(argStart + 1, argEnd - argStart - 1);
   

    std::stringstream    streamScope(argumentScope);
    while (streamScope >> word)
    {
        if (isType(word)) {
            streamScope >> word;
            if (word.empty()) {
                break;
            }
            if (isKeyword(word)) {
                throw ErrorMessage("Argument name can not be a keyword!\n");
            }
            ++argCount;
        }
    }
    streamScope.clear();
    
    funcBody = funcBody.substr(argEnd + 1, funcBody.size() - argEnd + 1);
    size_t  variableCount = functionVariableCount(funcBody);
    outputStream_ << functionName << " has " << argCount << " arguments and " << variableCount << " variables in the body\n";
}

